<?php

namespace App\Models;

use DateTime;
use PDO;

class Post extends Model
{
    // définir l'attribut $table au nom de la table dans la db
    protected $table = 'posts';

    // getPostPublished avoir les postes publiées état = 1
    public function getPostPublished()
    {
        return $this->querySQL("SELECT * FROM {$this->table} WHERE published = 1 ORDER BY created_at DESC");
    }

    // permet d'avoir les date dans un format bien précis
    public function getCreatedAt(): string
    {
        return (new DateTime($this->created_at))->format('d/m/y à H:i');
    }

    // faire en sort que le texte affiché dans la page index est de max 200 caractères 
    public function getExcerpt(): string
    {
        return substr($this->content, 0, 200) . '...';
    }

    // function d'un bouton fait avec heredoc pour voir l'article en entier (j'ai testé une autre manière de faire)
    public function getButton() : string
    {
        return <<<HTML
        <a href="/posts/$this->id" class="btn btn-primary">Lire l'article</a>
HTML;
    }


    // recup les tags d'un poste
    public function getTags()
    {
        return $this->querySQL("SELECT t.* FROM tags t
                                    INNER JOIN post_tag pt ON pt.tag_id = t.id
                                    INNER JOIN posts p ON pt.post_id = p.id
                                    WHERE pt.post_id = ?", [$this->id]);
    }


    // update un post en appelant la methode parent et aussi en rajoutant la modification des tags qui n'est pas géré par la méthode parent
    public function update_model(int $id, array $data, ?array $relations = null)
    {
        if(is_null($relations)){
            parent::update_model($id, $data);
        }
        parent::update_model($id, $data); // TODO: Change the autogenerated stub
        // delete tout les tags du post
        $stmt = $this->db->getPDO()->prepare('DELETE FROM post_tag WHERE post_id = ?');
        $result = $stmt->execute([$id]);

        // puis, on les réinsère tous
        foreach ($relations as $tagID) {
            $stmt = $this->db->getPDO()->prepare('INSERT post_tag (post_id, tag_id) VALUES (?, ?)');
            $stmt->execute([$id, $tagID]);
        }
        if($result) {
            return true;
        }
    }

    // recup le créateur du post
    public function getCreatorPost(): string
    {
        $user = $this->querySQL("SELECT username FROM users u
                                    INNER JOIN user_post up ON up.user_id = u.id
                                    WHERE up.post_id = ?", [$this->id]);
        // si c'est vide ça retourne rien sion ça retourne le username
        return !empty($user) ? $user[0]->username : '';
    }

    // creation d'un post
    public function create_model(array $data, ?array $relations = null)
    {
        parent::create_model($data);
        // permet de recup l'id du post qu'on vient de créer
        $id = $this->db->getPDO()->lastINSERTid();
        
        foreach ($relations as $tagId){
            // insere dans table intermédiaire post_tag quels tags a ce post
            $stmt = $this->db->getPDO()->prepare("INSERT post_tag (post_id, tag_id) VALUES (?, ?)");
            // insere dans table intermédiaire user_post quel user a fait quel post
            $stmtUserPost = $this->db->getPDO()->prepare("INSERT INTO user_post (user_id, post_id) VALUES (?, ?)");
            // execution des requetes avec les données
            $stmtUserPost->execute([$_SESSION['idUser'], $id]);
            $stmt->execute([$id, $tagId]);
        }
        return true;
    }

    // function qui permet de recupérer les postes du user qui est connecté et qui sont en état brouillon.
    public function myPostsDraft()
    {
        // recuper les posts du user avec la variable de session idUser
        return $this->querySQL('SELECT * FROM posts p
                                INNER JOIN user_post up on up.post_id=p.id
                                WHERE up.user_id=? AND published = 0 ORDER BY p.created_at DESC',[$_SESSION["idUser"]]) ;
    }

    // Les postes publiées d'un user
    public function myPostsPublished()
    {
        // recuper les posts du user avec la variable de session idUser
        return $this->querySQL('SELECT * FROM posts p
                                INNER JOIN user_post up on up.post_id=p.id
                                WHERE up.user_id=? AND published = 1 ORDER BY p.created_at DESC',[$_SESSION["idUser"]]) ;
    }

    // Permet de récup les élements nécessaire pour savoir si la personne qui est connectée est bien la personne qui modifie le poste
    public function checkPostAuthor(int $postId)
    {
        // Vérifier si l'association entre le post et l'utilisateur existe dans la table user_post
        return $this->querySQL("SELECT * FROM user_post WHERE post_id = ?", [$postId], true);
    }

    // Fonction pour la bar de recherche
    public function searchPosts($searchTerm)
    {
        // Effectuer la requête SQL pour rechercher dans les titres et le contenu des articles
        $querySearchTitleAndContent  = "SELECT * FROM posts WHERE published = 1 AND (title LIKE ? OR content LIKE ?)";
        // cherche la chaine de character
        $searchTerm = '%' . $searchTerm . '%';
        return $this->querySQL($querySearchTitleAndContent, [$searchTerm, $searchTerm]);
    }

    // pour le flux rss, fonction qui va chercher la date du dernier post créer (lastBuildDate)
    public function latestPost()
    {
        // recup le dernier post pour afficher la date du dernier post créé
        $queryLatestPost = 'SELECT created_at FROM posts ORDER BY created_at DESC LIMIT 0,1';
        $stmt = $this->db->getPDO()->query($queryLatestPost);
        return $stmt->fetch(PDO::FETCH_OBJ);
    }

    public function updatePostState(int $id, int $data)
    {
        $query = "UPDATE posts SET published = ? WHERE id = ?";
        return $this->querySQL($query, [$data, $id]);
    }
}
